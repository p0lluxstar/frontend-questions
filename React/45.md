## Разница между memo и useMemo?

**`React.memo`** и **`useMemo`** — это два инструмента оптимизации производительности в React, которые помогают избежать ненужных повторных рендеров компонентов и дорогостоящих вычислений. Несмотря на схожесть в названиях, они служат разным целям и используются в различных контекстах. Давайте рассмотрим их отличия, назначения и примеры использования.

---

## **React.memo**

### **Что такое `React.memo`?**

`React.memo` — это высокоуровневый компонент (Higher-Order Component, HOC), который позволяет мемоизировать функциональные компоненты. Он предотвращает повторный рендер компонента, если его пропсы не изменились. Это аналогично `PureComponent` для классовых компонентов.

### **Основная цель**

Оптимизация производительности за счёт предотвращения ненужных повторных рендеров компонентов, когда пропсы остаются неизменными.

### **Синтаксис**

```javascript
import React from 'react';

const MyComponent = (props) => {
  // Ваш компонент
};

export default React.memo(MyComponent);
```

### **Пример использования**

```jsx
import React from 'react';

// Функциональный компонент, который рендерит список
const ItemList = ({ items }) => {
  console.log('ItemList рендерится');
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
};

// Мемоизируем компонент ItemList
export default React.memo(ItemList);
```

**Использование в родительском компоненте:**

```jsx
import React, { useState } from 'react';
import ItemList from './ItemList';

const ParentComponent = () => {
  const [count, setCount] = useState(0);
  const items = [
    { id: 1, name: 'Яблоко' },
    { id: 2, name: 'Банан' },
    { id: 3, name: 'Вишня' },
  ];

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Увеличить: {count}</button>
      <ItemList items={items} />
    </div>
  );
};

export default ParentComponent;
```

**Что происходит:**

- Каждый раз при нажатии на кнопку, состояние `count` обновляется, и родительский компонент `ParentComponent` перерисовывается.
- Благодаря `React.memo`, компонент `ItemList` не будет перерисовываться, если пропсы `items` остаются неизменными, что экономит ресурсы и улучшает производительность.

### **Когда использовать `React.memo`**

- Когда функциональный компонент рендерит большое количество элементов или выполняет сложные вычисления.
- Когда компонент получает неизменные пропсы и его перерисовка не требуется при обновлении родительского компонента.
- Для компонентов, которые часто получают одинаковые пропсы.

### **Дополнительные возможности**

`React.memo` принимает вторым аргументом функцию сравнения (`areEqual`), которая позволяет определить, следует ли перерисовывать компонент вручную:

```javascript
export default React.memo(MyComponent, (prevProps, nextProps) => {
  // Возвращает true, если пропсы равны и перерисовка не требуется
  // Возвращает false, если пропсы изменились и компонент нужно перерисовать
});
```

---

## **useMemo**

### **Что такое `useMemo`?**

`useMemo` — это хук, который позволяет мемоизировать результат выполнения функции, предотвращая повторные дорогостоящие вычисления при каждом рендере, если зависимости не изменились.

### **Основная цель**

Оптимизация производительности за счёт мемоизации результатов вычислений, которые требуют значительных ресурсов, чтобы избежать их повторного выполнения при неизменных зависимостях.

### **Синтаксис**

```javascript
const memoizedValue = useMemo(() => {
  // Дорогостоящее вычисление
  return computeExpensiveValue(a, b);
}, [a, b]);
```

### **Пример использования**

```jsx
import React, { useState, useMemo } from 'react';

const ExpensiveCalculationComponent = ({ num }) => {
  // Дорогое вычисление, например, факториал числа
  const factorial = (n) => {
    console.log('Вычисление факториала');
    if (n === 0 || n === 1) return 1;
    return n * factorial(n - 1);
  };

  // Мемозируем результат вычисления
  const fact = useMemo(() => factorial(num), [num]);

  return (
    <div>
      <h2>Факториал числа {num} равен {fact}</h2>
    </div>
  );
};

const ParentComponent = () => {
  const [number, setNumber] = useState(5);
  const [count, setCount] = useState(0);

  return (
    <div>
      <ExpensiveCalculationComponent num={number} />
      <button onClick={() => setNumber(number + 1)}>Увеличить число</button>
      <button onClick={() => setCount(count + 1)}>Увеличить счетчик: {count}</button>
    </div>
  );
};

export default ParentComponent;
```

**Что происходит:**

- При нажатии на кнопку "Увеличить счетчик", состояние `count` обновляется, и родительский компонент `ParentComponent` перерисовывается.
- Благодаря `useMemo`, функция `factorial` не будет вызываться повторно, если значение `num` не изменилось. Это предотвращает повторное выполнение дорогостоящего вычисления.

### **Когда использовать `useMemo`**

- Когда у вас есть функции или вычисления, которые требуют значительных ресурсов и их выполнение может замедлить рендеринг компонента.
- Когда нужно мемоизировать результаты сложных вычислений, зависящих от определённых зависимостей.
- Для предотвращения повторных вычислений внутри компонента при неизменных зависимостях.

### **Важные моменты**

- **Зависимости**: Второй аргумент `useMemo` — это массив зависимостей. Результат мемоизации будет пересчитан только тогда, когда одно из значений в этом массиве изменится.
- **Не злоупотребляйте**: Использование `useMemo` добавляет сложность к коду и может привести к нежелательным побочным эффектам, если зависимости указаны неправильно. Используйте его только тогда, когда есть реальная необходимость в оптимизации производительности.
- **Мемоизация объектов и функций**: Для мемоизации объектов или функций, которые используются в пропсах или зависимостях других хуков, можно использовать `useMemo` вместе с `useCallback`.

---

## **Основные различия между `React.memo` и `useMemo`**

| **Аспект**                     | **`React.memo`**                                            | **`useMemo`**                                           |
|--------------------------------|-------------------------------------------------------------|---------------------------------------------------------|
| **Назначение**                 | Мемоизация целого функционального компонента               | Мемоизация результата выполнения функции внутри компонента |
| **Использование**              | Оборачивать функциональные компоненты для предотвращения их перерендера при неизменных пропсах | Использовать внутри компонента для мемоизации значений или функций |
| **Тип оптимизации**            | Оптимизация рендеринга компонентов                         | Оптимизация вычислений или создания мемоизированных значений |
| **Аргументы**                  | Компонент и (опционально) функция сравнения пропсов         | Функция для вычисления и массив зависимостей           |
| **Пример**                     | `export default React.memo(MyComponent);`                   | `const memoizedValue = useMemo(() => compute(), [deps]);` |
| **Роль в компонентах**         | Применяется к самим компонентам                             | Применяется внутри компонента для отдельных значений или функций |
| **Тип компонентов**            | Только для функциональных компонентов                      | Для любых значений или функций внутри компонентов       |

### **Когда использовать каждый из них**

- **`React.memo`**:
  - Когда нужно предотвратить повторный рендер компонента, если его пропсы не изменились.
  - Полезно для компонентов, которые получают часто неизменные пропсы или рендерят большое количество элементов.

- **`useMemo`**:
  - Когда внутри компонента есть дорогие вычисления, результаты которых можно мемоизировать.
  - Для создания мемоизированных объектов или функций, используемых в зависимостях других хуков (`useEffect`, `useCallback`).

### **Комбинированное использование**

В некоторых случаях вы можете использовать оба инструмента вместе для максимальной оптимизации:

```jsx
import React, { useMemo } from 'react';

const ChildComponent = React.memo(({ compute, value }) => {
  return <div>{compute(value)}</div>;
});

const ParentComponent = ({ value }) => {
  const compute = useMemo(() => {
    return (num) => num * 2;
  }, []);

  return <ChildComponent compute={compute} value={value} />;
};
```

**Что происходит:**

- `compute` мемоизируется с помощью `useMemo`, чтобы не создавать новую функцию при каждом рендере `ParentComponent`.
- `ChildComponent` оборачивается в `React.memo`, чтобы предотвратить его перерендер, если пропсы `compute` и `value` не изменились.

---

## **Заключение**

**`React.memo`** и **`useMemo`** — это мощные инструменты для оптимизации производительности в React-приложениях. Они помогают уменьшить количество ненужных рендеров и избежать повторных дорогостоящих вычислений. Однако важно использовать их осознанно, так как избыточное использование может привести к усложнению кода без значительной выгоды.

- **Используйте `React.memo`** для мемоизации функциональных компонентов и предотвращения их перерендера при неизменных пропсах.
- **Используйте `useMemo`** для мемоизации результатов вычислений или создания мемоизированных значений и функций внутри компонентов.

Понимание различий между этими инструментами и знание случаев их применения поможет вам создавать более эффективные и производительные React-приложения.

https://www.youtube.com/watch?v=l1Byo3u9WGY