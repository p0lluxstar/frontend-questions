## Модификаторы доступа в TypeScript?

Модификаторы доступа в TypeScript определяют уровень доступа к членам класса (свойствам и методам) из других частей программы. Они помогают управлять инкапсуляцией и доступом к данным в классе. В TypeScript существуют три основных модификатора доступа:

### 1. public

- **Описание**: Члены класса, помеченные как `public`, доступны из любого места в коде, где доступен экземпляр класса. Это значение по умолчанию для членов класса, если модификатор не указан.

- **Пример**:

```typescript
class Person {
  public name: string;

  constructor(name: string) {
    this.name = name;
  }

  public greet() {
    console.log(`Привет, меня зовут ${this.name}`);
  }
}

const person = new Person("Алиса");
person.greet(); // Вывод: Привет, меня зовут Алиса
```

### 2. private

- **Описание**: Члены класса, помеченные как `private`, доступны только внутри самого класса. Они не могут быть доступны из экземпляров класса или производных классов.

- **Пример**:

```typescript
class BankAccount {
  private balance: number;

  constructor(initialBalance: number) {
    this.balance = initialBalance;
  }

  public deposit(amount: number) {
    this.balance += amount;
  }

  public getBalance() {
    return this.balance;
  }
}

const account = new BankAccount(100);
account.deposit(50);
console.log(account.getBalance()); // Вывод: 150
// console.log(account.balance); // Ошибка: Property 'balance' is private
```

### 3. protected

- **Описание**: Члены класса, помеченные как `protected`, доступны внутри самого класса и в производных классах (наследниках), но не могут быть доступны из экземпляров класса. В отличие от private, где доступ ограничен только текущим классом, protected позволяет использовать свойство или метод в наследуемых классах.

### Особенности `protected`:
1. **Доступен в классе и его наследниках**: Свойства и методы с модификатором `protected` могут быть использованы как в базовом классе, так и в его подклассах.
2. **Не доступен вне класса**: Эти свойства и методы нельзя использовать напрямую за пределами класса или его подклассов (то есть нельзя вызвать через экземпляр класса).

### Пример использования `protected`:

```typescript
class Animal {
  protected name: string;

  constructor(name: string) {
    this.name = name;
  }

  protected makeSound(): void {
    console.log(`${this.name} издает звук.`);
  }
}

class Dog extends Animal {
  constructor(name: string) {
    super(name);
  }

  public bark(): void {
    this.makeSound();  // Доступ к защищенному методу makeSound() из базового класса
    console.log(`${this.name} лает.`);
  }
}

const dog = new Dog('Бобик');
dog.bark();  // Работает: Бобик издает звук. Бобик лает.

// Ошибки: вне класса или подкласса доступ к protected запрещен
dog.name;  // Ошибка: свойство 'name' защищено
dog.makeSound();  // Ошибка: метод 'makeSound' защищен
```

### Объяснение:
- **`protected name: string`** — свойство `name` защищено, оно доступно только внутри класса `Animal` и классов, которые от него наследуются, как в классе `Dog`.
- **`protected makeSound(): void`** — метод также защищён. Его можно вызвать внутри самого класса `Animal` или в наследуемом классе `Dog`, но не за пределами этих классов.

### Пример ошибки:

```typescript
const animal = new Animal('Лев');
animal.name;  // Ошибка: свойство 'name' защищено
animal.makeSound();  // Ошибка: метод 'makeSound' защищен
```

В этом случае попытка получить доступ к защищённым свойствам и методам вне класса или его наследников приводит к ошибке.

### Когда использовать `protected`:
- Когда нужно, чтобы свойство или метод были доступны в классе и его наследниках, но не за их пределами.
- Когда необходимо обеспечить частичную инкапсуляцию данных, предоставляя некоторую функциональность только наследуемым классам.

Таким образом, `protected` полезен для случаев, когда вы хотите ограничить доступ к данным и методам, но при этом дать возможность потомкам использовать эти данные и методы.

### Заключение

Модификаторы доступа в TypeScript позволяют разработчикам управлять видимостью и доступом к членам класса, что способствует инкапсуляции и более безопасному коду. Выбор правильного модификатора доступа помогает создавать более гибкие и поддерживаемые классы.