## В чем разница между типами never и void?

В TypeScript типы `never` и `void` имеют разные назначения и используются в различных контекстах. Вот основные различия между ними:

### 1. Тип `void`

- **Определение**: Тип `void` используется, чтобы указать, что функция не возвращает значение.
- **Применение**: Он часто применяется в функциях, которые выполняют какие-либо действия, но не возвращают результат. Например:

```typescript
function logMessage(message: string): void {
    console.log(message);
}
```

- **Возврат**: Функция с типом `void` может вернуть `undefined`, но это не обязательно. Основная идея — подчеркнуть, что функция не предназначена для возврата значимого значения.

### 2. Тип `never`

- **Определение**: Тип `never` указывает, что функция никогда не завершает свое выполнение. Это может происходить по нескольким причинам: функция может вызывать ошибку или зацикливаться бесконечно.
- **Применение**: Используется для функций, которые не достигают нормального завершения. Например:

```typescript
function throwError(message: string): never {
    throw new Error(message);
}

function infiniteLoop(): never {
    while (true) {
        // Бесконечный цикл
    }
}
```

- **Возврат**: Функция с типом `never` не возвращает никакого значения, так как она никогда не завершает выполнение. Это важно для TypeScript, поскольку помогает компилятору отслеживать пути выполнения.

### Основные отличия

| Aspect         | `void`                          | `never`                            |
|----------------|----------------------------------|------------------------------------|
| Завершение     | Функция может завершиться нормально | Функция никогда не завершится       |
| Возврат значения| Не возвращает значения, но может вернуть `undefined` | Не возвращает никаких значений      |
| Использование   | Для функций, которые выполняют действия без возврата | Для функций, которые генерируют ошибки или зацикливаются |

### Заключение

Использование `void` и `never` помогает сделать код более понятным и типизированным. Понимание этих различий способствует лучшему проектированию функций и управления их поведением в TypeScript.