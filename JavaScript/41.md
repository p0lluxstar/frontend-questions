## Что такое рекурсия?

**Рекурсия** в программировании — это метод, при котором функция вызывает сама себя для решения подзадачи той же проблемы. В JavaScript рекурсия используется для решения задач, которые можно разбить на более простые, похожие на исходную.

### Основные понятия рекурсии

1. **Базовый случай (условие выхода)**: Это условие, при котором рекурсивные вызовы прекращаются. Без базового случая рекурсия приведет к бесконечному циклу и переполнению стека вызовов (stack overflow).

2. **Рекурсивный случай**: Часть функции, где она вызывает сама себя с измененными аргументами для постепенного приближения к базовому случаю.

### Пример рекурсивной функции: вычисление факториала

Факториал числа `n` (обозначается как `n!`) — произведение всех натуральных чисел от 1 до `n`. Рекурсивная формула факториала выглядит так:

- `0! = 1` (базовый случай)
- `n! = n * (n-1)!` (рекурсивный случай)

**Реализация на JavaScript:**

```javascript
function factorial(n) {
    // Базовый случай
    if (n === 0) {
        return 1;
    }
    // Рекурсивный случай
    return n * factorial(n - 1);
}

console.log(factorial(5)); // Выведет: 120
```

### Пример рекурсивной функции: вычисление чисел Фибоначчи

Последовательность Фибоначчи — это последовательность чисел, в которой каждое число является суммой двух предыдущих, начиная с 0 и 1.

**Рекурсивная формула:**

- `F(0) = 0`
- `F(1) = 1`
- `F(n) = F(n-1) + F(n-2)` для `n > 1`

**Реализация на JavaScript:**

```javascript
function fibonacci(n) {
    // Базовые случаи
    if (n === 0) return 0;
    if (n === 1) return 1;
    // Рекурсивный случай
    return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(6)); // Выведет: 8
```

**Важно:** Рекурсивная реализация Фибоначчи неэффективна для больших `n`, так как приводит к множеству повторяющихся вычислений. В таких случаях лучше использовать итеративный подход или мемоизацию.

### Потенциальные проблемы рекурсии

1. **Переполнение стека вызовов (Stack Overflow)**:
   Если рекурсивные вызовы не имеют корректного базового случая или глубина рекурсии слишком велика, это может привести к ошибке переполнения стека.

   **Пример переполнения стека:**

   ```javascript
   function infiniteRecursion() {
       return infiniteRecursion();
   }

   infiniteRecursion(); // TypeError: Maximum call stack size exceeded
   ```

2. **Производительность**:
   Рекурсивные функции могут быть менее эффективны по сравнению с итеративными аналогами из-за накладных расходов на вызовы функций и управление стеком вызовов.

### Оптимизация рекурсии

1. **Мемоизация**:
   Техника кеширования результатов предыдущих вызовов функции, чтобы избежать повторных вычислений.

   **Пример мемоизированной функции Фибоначчи:**

   ```javascript
   const memo = {};

   function fibonacciMemo(n) {
       if (n in memo) {
           return memo[n];
       }
       if (n === 0) return 0;
       if (n === 1) return 1;
       memo[n] = fibonacciMemo(n - 1) + fibonacciMemo(n - 2);
       return memo[n];
   }

   console.log(fibonacciMemo(50)); // Вычисляется значительно быстрее
   ```

2. **Хвостовая рекурсия (Tail Recursion)**:
   Оптимизация, при которой последний вызов функции — рекурсивный вызов. Некоторые языки и компиляторы могут оптимизировать хвостовую рекурсию, но в текущих версиях JavaScript поддержка этой оптимизации ограничена.

   **Пример хвостовой рекурсии:**

   ```javascript
   function factorialTail(n, acc = 1) {
       if (n === 0) return acc;
       return factorialTail(n - 1, n * acc);
   }

   console.log(factorialTail(5)); // Выведет: 120
   ```

### Когда использовать рекурсию

- **Работа с деревьями и графами**: Рекурсия естественно подходит для обхода сложных структур данных.
- **Разделение задач на подзадачи**: Когда задача может быть разделена на похожие меньшие задачи.
- **Алгоритмы сортировки и поиска**: Некоторые алгоритмы, такие как быстрая сортировка (Quick Sort) и поиск в глубину (DFS), используют рекурсию.

### Итог

Рекурсия — мощный инструмент в JavaScript, который позволяет решать сложные задачи элегантно и лаконично. Однако важно правильно использовать базовые и рекурсивные случаи, а также учитывать потенциальные проблемы с производительностью и переполнением стека. В случаях, когда рекурсия неэффективна, рассмотрите возможность использования итеративных подходов или оптимизаций, таких как мемоизация.

https://www.youtube.com/watch?v=QY-ZldUrvZA