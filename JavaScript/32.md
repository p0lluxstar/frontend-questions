## Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?

В JavaScript копирование объектов играет важную роль при работе с данными. При копировании объектов необходимо понимать разницу между **поверхностной (shallow)** и **глубокой (deep)** копией, чтобы выбрать подходящий метод в зависимости от конкретной задачи.

### Основные различия между поверхностной и глубокой копией

| Характеристика                   | Поверхностная копия (Shallow Copy)                           | Глубокая копия (Deep Copy)                                     |
|----------------------------------|--------------------------------------------------------------|----------------------------------------------------------------|
| **Уровень копирования**          | Копирует только первый уровень свойств объекта.              | Копирует все уровни вложенных объектов.                        |
| **Влияние на вложенные объекты** | Вложенные объекты остаются ссылками на оригинальные объекты. | Вложенные объекты копируются полностью, создавая независимые экземпляры. |
| **Применение**                    | Подходит для объектов без вложенных структур или когда вложенные объекты должны быть общими. | Подходит для объектов со сложными иерархиями и когда требуется полная независимость от оригинала. |
| **Методы реализации**             | Простые и быстрые методы, такие как `Object.assign()` или spread-оператор. | Более сложные методы, включая рекурсию, использование `JSON` или сторонних библиотек. |

### Поверхностная копия (Shallow Copy)

**Описание:**
Поверхностная копия создаёт новый объект, копируя все свойства из исходного объекта. Однако, если некоторые свойства являются объектами (вложенными объектами), копируются только ссылки на эти объекты, а не их содержимое.

**Методы создания поверхностной копии:**

1. **Spread-оператор (`...`)**

   ```javascript
   const original = { a: 1, b: { c: 2 } };
   const shallowCopy = { ...original };

   console.log(shallowCopy); // { a: 1, b: { c: 2 } }

   // Изменение вложенного объекта влияет на оба объекта
   shallowCopy.b.c = 3;
   console.log(original.b.c); // 3
   ```

2. **`Object.assign()`**

   ```javascript
   const original = { a: 1, b: { c: 2 } };
   const shallowCopy = Object.assign({}, original);

   console.log(shallowCopy); // { a: 1, b: { c: 2 } }

   // Изменение вложенного объекта влияет на оба объекта
   shallowCopy.b.c = 4;
   console.log(original.b.c); // 4
   ```

3. **`Array.prototype.slice()` для массивов**

   Для копирования массивов можно использовать метод `slice()`:

   ```javascript
   const originalArray = [1, 2, { a: 3 }];
   const shallowCopyArray = originalArray.slice();

   console.log(shallowCopyArray); // [1, 2, { a: 3 }]

   // Изменение вложенного объекта влияет на оба массива
   shallowCopyArray[2].a = 4;
   console.log(originalArray[2].a); // 4
   ```

**Применение:**
Поверхностная копия подходит, когда объект не содержит вложенных объектов или когда необходимо, чтобы вложенные объекты оставались общими между копией и оригиналом.

### Глубокая копия (Deep Copy)

**Описание:**
Глубокая копия создаёт полностью независимую копию объекта, включая все его вложенные объекты. Изменения в глубокой копии не влияют на оригинальный объект и наоборот.

**Методы создания глубокой копии:**

1. **Использование `JSON.parse` и `JSON.stringify`**

   Этот метод простой и быстрый, но имеет ограничения (например, не поддерживает функции, `undefined`, `Symbol` и другие специальные типы данных). В этих случаях если попадается например функция то функция просто не будет скопирована, ошибки не будет.

   ```javascript
   const original = { a: 1, b: { c: 2 } };
   const deepCopy = JSON.parse(JSON.stringify(original));

   console.log(deepCopy); // { a: 1, b: { c: 2 } }

   // Изменение вложенного объекта не влияет на оригинал
   deepCopy.b.c = 3;
   console.log(original.b.c); // 2
   ```

2. **Рекурсивная функция**

   Создание собственной функции для глубокого копирования, которая рекурсивно копирует все вложенные объекты.

   ```javascript
   function deepClone(obj) {
     if (obj === null || typeof obj !== 'object') {
       return obj;
     }

     if (Array.isArray(obj)) {
       const arrCopy = [];
       for (let item of obj) {
         arrCopy.push(deepClone(item));
       }
       return arrCopy;
     }

     const objCopy = {};
     for (let key in obj) {
       if (obj.hasOwnProperty(key)) {
         objCopy[key] = deepClone(obj[key]);
       }
     }
     return objCopy;
   }

   const original = { a: 1, b: { c: 2 } };
   const deepCopy = deepClone(original);

   deepCopy.b.c = 3;
   console.log(original.b.c); // 2
   ```

3. **Использование библиотеки `lodash`**

   Библиотека `lodash` предоставляет функцию `_.cloneDeep()` для глубокого копирования объектов.

   ```javascript
   const _ = require('lodash');

   const original = { a: 1, b: { c: 2 } };
   const deepCopy = _.cloneDeep(original);

   deepCopy.b.c = 3;
   console.log(original.b.c); // 2
   ```

4. **Использование структурированных копий (`structuredClone`)**

   Современный метод `structuredClone` (доступен в некоторых браузерах и средах) позволяет создавать глубокие копии объектов, включая многие сложные типы данных.

   ```javascript
   const original = { a: 1, b: { c: 2 } };
   const deepCopy = structuredClone(original);

   deepCopy.b.c = 3;
   console.log(original.b.c); // 2
   ```

   **Примечание:** Метод `structuredClone` ещё не поддерживается во всех средах выполнения. Проверяйте совместимость перед использованием.

**Применение:**
Глубокая копия необходима, когда нужно создать полностью независимую копию объекта с его вложенными структурами, чтобы изменения в копии не затрагивали оригинал.

### Важные замечания

1. **Циклические ссылки:**
   Методы, использующие `JSON.stringify` или рекурсию без обработки циклических ссылок, вызовут ошибку при копировании объектов с циклическими ссылками. В таких случаях рекомендуется использовать специализированные библиотеки, такие как `lodash` или `circular-json`.

2. **Производительность:**
   Глубокая копия требует больше ресурсов и времени по сравнению с поверхностной копией. Используйте её только тогда, когда это действительно необходимо.

3. **Типы данных:**
   Некоторые типы данных, такие как функции, `Date`, `Map`, `Set`, `RegExp` и другие, требуют специальной обработки при глубоком копировании, так как они не поддерживаются методами, основанными на `JSON`.

### Примеры использования

**Поверхностная копия с использованием spread-оператора:**

```javascript
const original = { a: 1, b: { c: 2 } };
const shallowCopy = { ...original };

shallowCopy.a = 10;
shallowCopy.b.c = 20;

console.log(original);    // { a: 1, b: { c: 20 } }
console.log(shallowCopy); // { a: 10, b: { c: 20 } }
```

**Глубокая копия с использованием `lodash`:**

```javascript
const _ = require('lodash');

const original = { a: 1, b: { c: 2 } };
const deepCopy = _.cloneDeep(original);

deepCopy.a = 10;
deepCopy.b.c = 20;

console.log(original);    // { a: 1, b: { c: 2 } }
console.log(deepCopy);    // { a: 10, b: { c: 20 } }
```

### Заключение

Понимание различий между поверхностной и глубокой копией объектов в JavaScript важно для предотвращения неожиданных побочных эффектов при работе с данными. Выбор подходящего метода копирования зависит от структуры ваших объектов и требований к независимости копий. Поверхностная копия эффективна для простых объектов без вложенных структур, тогда как глубокая копия необходима для сложных иерархий данных.

Используйте поверхностную копию для быстрых и простых операций, а глубокую копию — когда требуется полная изоляция данных и предотвращение влияния изменений на оригинальные объекты.