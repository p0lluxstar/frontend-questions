## Почему результат сравнения 2х объектов это false?

В JavaScript объекты сравниваются по **ссылке**, а не по их содержимому. Это означает, что даже если два объекта имеют одинаковые свойства и значения, они будут считаться **разными**, если это не одна и та же ссылка.

### Пример:

```javascript
let obj1 = { name: 'John' };
let obj2 = { name: 'John' };

console.log(obj1 === obj2);  // false
```

Здесь объекты `obj1` и `obj2` выглядят одинаково, но они находятся в разных местах в памяти, поэтому при сравнении с помощью `===` (строгое равенство) результат будет `false`. Сравнение проверяет не содержимое объектов, а их ссылки в памяти.

### Сравнение объектов по ссылке:

```javascript
let obj1 = { name: 'John' };
let obj2 = obj1;

console.log(obj1 === obj2);  // true
```

В этом примере оба объекта (`obj1` и `obj2`) ссылаются на один и тот же объект в памяти, поэтому результат сравнения будет `true`.

### Почему это происходит:

В JavaScript примитивные типы (например, числа, строки, булевы значения) сравниваются по значению, а объекты, включая массивы и функции, сравниваются по ссылке. Когда вы присваиваете объект переменной, вы сохраняете ссылку на этот объект, а не его копию.

### Как сравнивать объекты по содержимому:

Если нужно сравнить объекты **по содержимому**, можно, например, использовать метод `JSON.stringify()` для преобразования объектов в строки:

```javascript
let obj1 = { name: 'John' };
let obj2 = { name: 'John' };

console.log(JSON.stringify(obj1) === JSON.stringify(obj2));  // true
```

Однако это работает только для простых объектов и не подходит для объектов, содержащих методы или сложные структуры данных (например, циклические ссылки). Для более сложных объектов можно использовать специализированные библиотеки, такие как `lodash` (функция `_.isEqual`), для глубокого сравнения объектов.