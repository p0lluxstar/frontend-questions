## Разница между `[[Prototype]]` и `__proto__`?

В JavaScript **`[[Prototype]]`** и **`__proto__`** — это два способа ссылки на прототип объекта, но они имеют несколько важных различий по своей сути и использованию.

### 1. **[[Prototype]]** (внутреннее свойство)
- **`[[Prototype]]`** — это **внутреннее (неявное)** свойство, которое указывает на прототип объекта. Это внутреннее свойство, которое является частью механизма наследования объектов в JavaScript, и оно не доступно напрямую в коде.
- Оно используется механизмом прототипного наследования, чтобы объект мог наследовать методы и свойства от другого объекта.

В JavaScript **`[[Prototype]]`** не является доступным для прямого обращения, но оно лежит в основе работы с прототипами объектов.

### 2. **`__proto__`** (свойство)
- **`__proto__`** — это **явное свойство**, доступное для чтения и записи, которое позволяет получить или установить значение внутреннего свойства **`[[Prototype]]`** объекта. Это свойство является частью стандарта, но в современном JavaScript его использование не рекомендуется, так как оно не является частью официального ECMAScript (и было добавлено позднее для удобства работы с прототипами).
  
- Это свойство может быть использовано для манипулирования прототипом объекта, что позволяет задавать прототип объекта вручную или проверять, на какой объект он ссылается.

#### Пример использования `__proto__`:
```javascript
const obj = {};
console.log(obj.__proto__);  // [Object: null prototype] - прототип объекта по умолчанию

// Устанавливаем прототип вручную
const newPrototype = { sayHello: () => console.log("Hello!") };
obj.__proto__ = newPrototype;
obj.sayHello(); // Hello!
```

### 3. **Основные различия**:

| **Характеристика**           | **`[[Prototype]]`**                                | **`__proto__`**                                 |
|------------------------------|---------------------------------------------------|-------------------------------------------------|
| **Тип**                       | Внутреннее свойство (не доступно напрямую)        | Явное свойство, доступное для чтения/записи     |
| **Использование**             | Используется механизмом прототипного наследования | Позволяет работать с прототипами объекта вручную |
| **Доступность**               | Не доступно напрямую (является внутренней деталью) | Доступно через свойства объекта                 |
| **Рекомендации по использованию** | Не используется напрямую в коде                  | Использование `__proto__` считается устаревшим  |

### 4. **Как работают `[[Prototype]]` и `__proto__`?**
Когда мы обращаемся к свойствам объекта, JavaScript сначала ищет их в самом объекте. Если свойство не найдено, оно ищет его в объекте, на который ссылается **`[[Prototype]]`** (или **`__proto__`**). Этот процесс называется **поиск по цепочке прототипов**.

#### Пример:
```javascript
const animal = {
  speak() {
    console.log("Animal makes a sound");
  }
};

const dog = Object.create(animal); // `dog.__proto__` ссылается на `animal`

dog.speak(); // Animal makes a sound
```

Здесь:
- У объекта `dog` нет метода `speak`, но он находит его через цепочку прототипов (через `[[Prototype]]` или `__proto__`), которая ссылается на объект `animal`.

### 5. **Использование `Object.getPrototypeOf` и `Object.setPrototypeOf`**:
Для работы с прототипами рекомендуется использовать стандартные методы:
- **`Object.getPrototypeOf(obj)`** — возвращает **`[[Prototype]]`** объекта `obj`. Это полезный метод для получения прототипа объекта. Он позволяет понять, от чего наследуется объект, и упрощает работу с цепочкой прототипов.

- **`Object.setPrototypeOf(obj, prototype)`** — устанавливает **`[[Prototype]]`** объекта `obj` на новый объект. Это метод в JavaScript, который позволяет установить прототип объекта, то есть изменить его свойство [[Prototype]].

Эти методы дают более надежный способ взаимодействия с прототипами и заменяют использование `__proto__`.

#### Пример с `Object.getPrototypeOf`:
```javascript
const animal = {
  sayHello: function () {
    console.log("Hello from animal!");
  },
  name: 'bobik'
};

const dog = Object.create(animal); // Создаём объект dog с прототипом animal
dog.bark = function () {
  console.log("Woof! Woof!");
};

// Проверим прототип объекта dog
console.log(Object.getPrototypeOf(dog) === animal); // true
console.log(Object.getPrototypeOf(dog)); // { sayHello: [Function: sayHello], name: 'bobik' }

// Вызов метода из прототипа
dog.sayHello(); // "Hello from animal!"
```

### Объяснение:
1. **`animal`** — объект, который служит прототипом.
2. **`dog`** создаётся с помощью `Object.create(animal)`, где `animal` становится прототипом объекта `dog`.
3. С помощью **`Object.getPrototypeOf(dog)`** мы получаем прототип объекта `dog` (в данном случае, это `animal`).
4. Метод `sayHello`, определённый в `animal`, доступен объекту `dog` через прототип.

#### Пример с `Object.setPrototypeOf`:
```javascript
const animal = { speak() { console.log("Animal speaks"); } };
const dog = { name: "Rex" };

Object.setPrototypeOf(dog, animal);  // Устанавливаем animal как прототип dog
dog.speak();  // Animal speaks
```

### Заключение:
- **`[[Prototype]]`** — это внутреннее свойство, которое лежит в основе прототипного наследования в JavaScript.
- **`__proto__`** — это явное, доступное свойство, которое позволяет читать и изменять прототип объекта, но оно устарело в пользу стандартных методов `Object.getPrototypeOf()` и `Object.setPrototypeOf()`.

Использование **`__proto__`** считается не рекомендованным в новых проектах, а для работы с прототипами следует использовать методы `Object.getPrototypeOf` и `Object.setPrototypeOf`.