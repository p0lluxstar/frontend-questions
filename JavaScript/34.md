## Как передаются параметры в функцию: по ссылке или по значению?

В JavaScript параметры функций передаются **по значению**. Однако важно понимать, что этот принцип работает по-разному для **примитивных типов** и **объектных типов** данных. Давайте рассмотрим подробнее, как это работает.

### Примитивные типы vs. Объектные типы

1. **Примитивные типы**:
   - **Типы**: `string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`.
   - **Передача по значению**: При передаче примитивных типов в функцию создаётся **копия** значения. Изменения внутри функции не затрагивают оригинальную переменную.

2. **Объектные типы**:
   - **Типы**: `object`, `array`, `function`.
   - **Передача по значению ссылки**: При передаче объектных типов в функцию создаётся **копия ссылки** на объект. Таким образом, внутри функции можно изменять свойства объекта, и эти изменения будут видны за пределами функции. Однако сама ссылка копируется, поэтому переназначение ссылки внутри функции не влияет на оригинальную переменную.

### Детальное объяснение

#### Примитивные типы

Когда вы передаёте примитивное значение в функцию, JavaScript создаёт копию этого значения. Любые изменения этой копии внутри функции не повлияют на исходную переменную.

**Пример:**

```javascript
function changePrimitive(value) {
  value = 100;
  console.log("Внутри функции:", value); // 100
}

let num = 50;
changePrimitive(num);
console.log("Снаружи функции:", num); // 50
```

**Объяснение:**
- `num` передаётся в функцию как копия значения `50`.
- Внутри функции `value` изменяется на `100`, но это не влияет на `num` вне функции.

#### Объектные типы

Когда вы передаёте объект в функцию, JavaScript копирует **ссылку** на этот объект. Это означает, что внутри функции вы работаете с тем же объектом, что и снаружи, и можете изменять его свойства.

**Пример:**

```javascript
function changeObject(obj) {
  obj.value = 100;
  console.log("Внутри функции:", obj.value); // 100
}

let myObj = { value: 50 };
changeObject(myObj);
console.log("Снаружи функции:", myObj.value); // 100
```

**Объяснение:**
- `myObj` передаётся в функцию как ссылка на объект `{ value: 50 }`.
- Внутри функции свойство `value` объекта изменяется на `100`.
- Изменение видно и за пределами функции, так как обе переменные (`obj` внутри функции и `myObj` вне функции) ссылаются на один и тот же объект.

**Важно:** Хотя ссылка на объект передаётся по значению, сама структура объекта остаётся неизменной. Это означает, что вы можете изменять содержимое объекта, но не можете изменить саму ссылку на другой объект без дополнительного шага.

**Пример переназначения ссылки:**

```javascript
function reassignObject(obj) {
  obj = { value: 200 };
  console.log("Внутри функции:", obj.value); // 200
}

let myObj = { value: 50 };
reassignObject(myObj);
console.log("Снаружи функции:", myObj.value); // 50
```

**Объяснение:**
- Внутри функции `reassignObject` переменная `obj` переназначается на новый объект `{ value: 200 }`.
- Это переназначение **не влияет** на `myObj` вне функции, так как `obj` — это копия ссылки на оригинальный объект.

### Мемоизация и передача параметров

Понимание передачи параметров важно при реализации техник оптимизации, таких как мемоизация. Например, при мемоизации функций, которые принимают объекты в качестве аргументов, нужно учитывать, что изменение свойств объекта может влиять на кешированные результаты.

### Заключение

В JavaScript все параметры функций передаются **по значению**. Для **примитивных типов** это означает копирование самого значения, а для **объектных типов** — копирование ссылки на объект. Понимание этого механизма помогает избегать неожиданных ошибок и писать более надёжный код.

### Рекомендации

1. **Используйте `const` для неизменяемых ссылок**:
   Это помогает предотвратить случайное переназначение переменных-ссылок.

   ```javascript
   const myObj = { value: 50 };
   // myObj = { value: 100 }; // Ошибка: присвоение константе
   ```

2. **Клонируйте объекты при необходимости**:
   Если вы хотите избежать изменений оригинальных объектов внутри функций, создавайте их копии.

   ```javascript
   function modifyObject(obj) {
     let copy = { ...obj }; // Поверхностное копирование
     copy.value = 100;
     return copy;
   }

   let original = { value: 50 };
   let modified = modifyObject(original);
   console.log(original.value); // 50
   console.log(modified.value); // 100
   ```

3. **Используйте библиотеки для глубокого клонирования**:
   Для сложных объектов с вложенными структурами можно использовать библиотеки, такие как `lodash`.

   ```javascript
   const _ = require('lodash');

   function deepModify(obj) {
     let copy = _.cloneDeep(obj);
     copy.value = 100;
     return copy;
   }

   let original = { value: 50, nested: { a: 1 } };
   let modified = deepModify(original);
   modified.nested.a = 2;

   console.log(original.nested.a); // 1
   console.log(modified.nested.a); // 2
   ```

Понимание механизма передачи параметров позволяет более эффективно управлять состоянием и избегать нежелательных побочных эффектов в вашем коде.