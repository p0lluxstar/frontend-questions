## Как передаются параметры в функцию: по ссылке или по значению?

В JavaScript параметры функций передаются **по значению**. Однако важно понимать, что этот принцип работает по-разному для **примитивных типов** и **объектных типов** данных. Давайте рассмотрим подробнее, как это работает.

### Примитивные типы vs. Объектные типы

1. **Примитивные типы**:
   - **Типы**: `string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`.
   - **Передача по значению**: При передаче примитивных типов в функцию создаётся **копия** значения. Изменения внутри функции не затрагивают оригинальную переменную.

2. **Объектные типы**:
   - **Типы**: `object`, `array`, `function`.
   - **Передача по значению ссылки**: При передаче объектных типов в функцию создаётся **копия ссылки** на объект. Таким образом, внутри функции можно изменять свойства объекта, и эти изменения будут видны за пределами функции. Однако сама ссылка копируется, поэтому переназначение ссылки внутри функции не влияет на оригинальную переменную.

### Детальное объяснение

#### Примитивные типы

Когда вы передаёте примитивное значение в функцию, JavaScript создаёт копию этого значения. Любые изменения этой копии внутри функции не повлияют на исходную переменную.

**Пример:**

```javascript
function changePrimitive(value) {
  value = 100;
  console.log("Внутри функции:", value); // 100
}

let num = 50;
changePrimitive(num);
console.log("Снаружи функции:", num); // 50
```

**Объяснение:**
- `num` передаётся в функцию как копия значения `50`.
- Внутри функции `value` изменяется на `100`, но это не влияет на `num` вне функции.

#### Объектные типы

Когда вы передаёте объект в функцию, JavaScript копирует **ссылку** на этот объект. Это означает, что внутри функции вы работаете с тем же объектом, что и снаружи, и можете изменять его свойства.

**Пример:**

```javascript
function modifyObject(obj) {
  // Изменяем свойство объекта
  obj.name = 'Modified';

  // Пробуем переназначить ссылку на другой объект
  obj = { name: 'New Object' };
  console.log('Внутри функции:', obj); // { name: 'New Object' }
}

const originalObject = { name: 'Original' };

console.log('До вызова функции:', originalObject); // { name: 'Original' }

// Передаем объект в функцию
modifyObject(originalObject);

console.log('После вызова функции:', originalObject); // { name: 'Modified' }
```

### Объяснение:
1. **Передача объекта в функцию**:
   - Когда мы передаем `originalObject` в функцию, создается копия ссылки на этот объект.
   - Внутри функции обе ссылки (`originalObject` и `obj`) указывают на один и тот же объект в памяти.

2. **Изменение свойства**:
   - В строке `obj.name = 'Modified';` мы изменяем свойство объекта, на который указывает ссылка.
   - Это изменение видно за пределами функции, потому что обе ссылки (`originalObject` и `obj`) всё ещё указывают на один и тот же объект.

3. **Переназначение ссылки**:
   - В строке `obj = { name: 'New Object' };` мы переназначаем локальную переменную `obj` на новый объект.
   - Это не влияет на `originalObject`, так как его ссылка остаётся неизменной.

### Вывод:
```
До вызова функции: { name: 'Original' }
Внутри функции: { name: 'New Object' }
После вызова функции: { name: 'Modified' }
```
Таким образом, свойства объекта можно изменить внутри функции, но переназначение ссылки внутри функции не влияет на оригинальную переменную.

### Мемоизация и передача параметров

Понимание передачи параметров важно при реализации техник оптимизации, таких как мемоизация. Например, при мемоизации функций, которые принимают объекты в качестве аргументов, нужно учитывать, что изменение свойств объекта может влиять на кешированные результаты.

### Заключение

В JavaScript все параметры функций передаются **по значению**. Для **примитивных типов** это означает копирование самого значения, а для **объектных типов** — копирование ссылки на объект. Понимание этого механизма помогает избегать неожиданных ошибок и писать более надёжный код.

### Рекомендации

1. **Используйте `const` для неизменяемых ссылок**:
   Это помогает предотвратить случайное переназначение переменных-ссылок.

   ```javascript
   const myObj = { value: 50 };
   // myObj = { value: 100 }; // Ошибка: присвоение константе
   ```

2. **Клонируйте объекты при необходимости**:
   Если вы хотите избежать изменений оригинальных объектов внутри функций, создавайте их копии.

   ```javascript
   function modifyObject(obj) {
     let copy = { ...obj }; // Поверхностное копирование
     copy.value = 100;
     return copy;
   }

   let original = { value: 50 };
   let modified = modifyObject(original);
   console.log(original.value); // 50
   console.log(modified.value); // 100
   ```

3. **Используйте библиотеки для глубокого клонирования**:
   Для сложных объектов с вложенными структурами можно использовать библиотеки, такие как `lodash`.

   ```javascript
   const _ = require('lodash');

   function deepModify(obj) {
     let copy = _.cloneDeep(obj);
     copy.value = 100;
     return copy;
   }

   let original = { value: 50, nested: { a: 1 } };
   let modified = deepModify(original);
   modified.nested.a = 2;

   console.log(original.nested.a); // 1
   console.log(modified.nested.a); // 2
   ```